<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Word Search Game</title>


<style> /* This part is CSS coding */
        /* May as well consider this the front-end set up*/

  body { /* Styling for the page */
    font-family: Arial, sans-serif;
    background: #f4f4f4;
    display: flex;
    justify-content: center;
    padding: 20px;
  }

  .game { /* Game container */ 
    display: flex;
    gap: 30px;
  }

  table { /* Styles the whole grid */
    border-collapse: collapse;
    user-select: none;
  }

  td { /* Styles each letter cell within the grid */
    width: 26px;
    height: 26px;
    border: 1px solid #333;
    text-align: center;
    font-size: 20px;
    cursor: pointer;
    background: white;
  }

  td.selected { background: #add8e6; } /* Style for selected letters (greyish) */
  td.found { background: #90ee90; } /* Style for found words (green) */

  .timer { /* Timer display */
    font-size: 22px;
    font-weight: bold;
    margin-bottom: 10px;
  }

  .found-word { /* Strikes through a found word */
    text-decoration: line-through;
    color: green;
  }
</style> <!-- Ends CSS Styling -->
</head>

<body> <!-- Now it's time to start making the visible content-->

<div class="game"> <!-- Main game container, the grid -->
  <div>
    <div class="timer" id="timer">Time: 00:00</div> <!-- Timer text -->
    <table id="grid"></table> <!-- Empty table for the grid, will be filled later -->
  </div>

  <div class="words"> <!-- The words to find, displayed on the right -->
    <h3>Find these words:</h3>
    <ul id="wordList"></ul>
  </div>
</div>

<script> // Time to start JavaScript
/* ================= SETTINGS ================= */

const size = 8;
const words = ["HTML", "JAVA", "CSS", "CODE", "WEB"];
const directions = [
  [0, 1], // Horizontal
  [1, 0], // Vertical
  [1, 1], // y = -x
  [-1, 1] // y = x
];

let foundCount = 0; // How many words have been found

/* ================= TIMER ================= */

let seconds = 0; 
const timerInterval = setInterval(() => { //Runs every second
  seconds++;
  const m = String(Math.floor(seconds / 60)).padStart(2, "0");
  const s = String(seconds % 60).padStart(2, "0");
  timer.textContent = `Time: ${m}:${s}`;
}, 1000); //Update display

/* ================= GRID ================= */

  //Creates the grid rows and columns, then fill with nothing for now
const grid = Array(size).fill().map(() => Array(size).fill(""));

function placeWord(word) { //Places the word
  let placed = false;
  while (!placed) { //Keep trying to place the word

    //start by setting a random direction, x coord, y coord
    const [dr, dc] = directions[Math.floor(Math.random() * directions.length)];
    const r0 = Math.floor(Math.random() * size);
    const c0 = Math.floor(Math.random() * size);

    let ok = true; // Assume it fits for now

    for (let i = 0; i < word.length; i++) { // Check each letter of the word
      const r = r0 + dr * i;
      const c = c0 + dc * i;
      if ( //If out of bounds or there's conflicting letters,
        r < 0 || c < 0 || r >= size || c >= size ||
        (grid[r][c] && grid[r][c] !== word[i])
      ) {
        ok = false; //Then it doesn't fit
        break;
      }
    }

    if (ok) { //If it fits, place th letters and mark as placed
      for (let i = 0; i < word.length; i++) {
        grid[r0 + dr * i][c0 + dc * i] = word[i];
      }
      placed = true;
    }
  }
}

words.forEach(placeWord); //Place all the words

for (let r = 0; r < size; r++) {
  for (let c = 0; c < size; c++) {
    if (!grid[r][c]) { //If a cell is empty, place a random letter
      grid[r][c] = String.fromCharCode(65 + Math.random() * 26);
    }
  }
}

/* ================= RENDER ================= */

const table = document.getElementById("grid"); // Get table element

grid.forEach((row, r) => { // Run through each row
  const tr = document.createElement("tr"); // Create a table row

  row.forEach((ch, c) => { // Run through each column of some row
    const td = document.createElement("td"); // Create a column row 

    td.textContent = ch; // Put character inside
    td.dataset.row = r; // Store row index
    td.dataset.col = c; // Store column index 
    td.draggable = false; // Disable native dragging
    tr.appendChild(td); // Add cell to row
  });
  table.appendChild(tr); // Add row to table
});

const wordList = document.getElementById("wordList"); // Get list
words.forEach(w => {
  const li = document.createElement("li"); // Create list item
  li.textContent = w; // Set text
  li.id = w; // Set TD
  wordList.appendChild(li); //Add to list item
});

/* ================= SELECTION (STABLE) ================= */

let startCell = null; // Cell where drag started
let direction = null; // Locked direction
let selected = []; // Selected cells in drag
let isDragging = false; // Drag state

document.addEventListener("dragstart", e => e.preventDefault()); // Prevent native drag behavior completely


table.addEventListener("mousedown", e => { //Check for mouse pressed
  // Basically initialize the drag
  if (e.target.tagName !== "TD") return; //Only allow cells to be pressed
  e.preventDefault(); //Prevent browser drag

  clearSelection(); //Clear previous selection
  startCell = e.target; //Set start cell
  selected = [startCell]; 
  startCell.classList.add("selected"); 
  isDragging = true; 
});


document.addEventListener("mousemove", e => { // When the mouse moves
  if (!isDragging) return; // Only if dragging
  e.preventDefault(); // Only allow cells to be highlighted

  const cell = document.elementFromPoint(e.clientX, e.clientY); //Cell under the mouse
  if (!cell || cell.tagName !== "TD") return; // Ignore invalid targets

  const r0 = +startCell.dataset.row; // Start row
  const c0 = +startCell.dataset.col; // Start col
  const r1 = +cell.dataset.row; // Current row
  const c1 = +cell.dataset.col; // Current col

  const dRow = r1 - r0; // Row distance
  const dCol = c1 - c0; // Column distance

  const absRow = Math.abs(dRow); // Absolute row distance
  const absCol = Math.abs(dCol); // Absolute column distance 

  if (!direction) { // If not locked yet, wait for movement
    if (absRow + absCol < 2) return; 

    if (Math.abs(absRow - absCol) <= 1) {  // Diagonal
      direction = [Math.sign(dRow), Math.sign(dCol)];
    } else if (absCol > absRow) { // Horizontal
      direction = [0, Math.sign(dCol)];
    } else { // Vertical
      direction = [Math.sign(dRow), 0];
    }
  }

  clearSelection(); // Clear previous highlights

  const [dr, dc] = direction; // Direction components

  let steps; // Number of highlighted cells
  if (dr !== 0 && dc !== 0) { // If diagonal
    steps = Math.min(absRow, absCol); // Take the shortest axis
  } else { // If horizontal or vertical
    steps = Math.max(absRow, absCol); // Take the full distance
  }

  for (let i = 0; i <= steps; i++) { //Loop through each step
    const r = r0 + dr * i; // Row
    const c = c0 + dc * i; // Column
    if (r < 0 || c < 0 || r >= size || c >= size) break; //Check grid bounds, break if out of bounds

    const td = document.querySelector( // Get the HTML cell
      `td[data-row='${r}'][data-col='${c}']` 
    );
    td.classList.add("selected"); // Hightlight cell
    selected.push(td); // Save it for word checking later
  }
});

document.addEventListener("mouseup", () => { // Mouse released, check word and stop dragging
  if (isDragging) { 
    checkWord();
    isDragging = false;
    direction = null;
  }
});

/* ================= WORD CHECK ================= */

function clearSelection() { // Clear selected letters
  selected.forEach(c => c.classList.remove("selected"));
  selected = [];
}

function checkWord() { // Check if a word was found
  const word = selected.map(c => c.textContent).join(""); // Build word
  const rev = word.split("").reverse().join(""); // Reverse word

  if (words.includes(word) || words.includes(rev)) { // If valid
    selected.forEach(c => c.classList.add("found")); // Mark found

    const el = document.getElementById(word) || document.getElementById(rev); // Word list item
    if (el && !el.classList.contains("found-word")) { // If not already found
      el.classList.add("found-word"); // Mark found
      foundCount++; // Increase count of found words

      if (foundCount === words.length) { // If all found
        clearInterval(timerInterval); // Stop timer
        alert("ðŸŽ‰ All words found!"); // Show win message
      }
    }
  } else { // If invalid word
    clearSelection(); 
  }
}
</script> <!-- End JavaScript -->

</body> <!-- End body -->
</html> <!-- End HTML -->
